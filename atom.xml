<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><title type="text">Gopher</title><subtitle type="html">Gopher</subtitle><updated>2021-05-13T07:12:50+00:00</updated><id>http://lt7.top/</id><link rel="alternate" type="text/html" href="http://lt7.top/"/><link rel="self" type="application/atom+xml" href="http://lt7.top/atom.xml"/><author><name>lintao</name><uri>http://lt7.top/</uri><email>mrqter@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><generator uri="https://gohugo.io/" version="0.83.1">Hugo</generator><entry><title type="text">什么是网络协议?</title><link rel="alternate" type="text/html" href="http://lt7.top/posts/my-first-post/"/><id>http://lt7.top/posts/my-first-post/</id><updated>2021-05-13T07:12:48+00:00</updated><published>2021-05-13T14:55:10+08:00</published><author><name>lintao</name><uri>https://lt7.top/</uri><email>mrqter@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html"/><content type="html"/></entry><entry><title type="text">OpenApi2.0</title><link rel="alternate" type="text/html" href="http://lt7.top/posts/openapi2.0/"/><id>http://lt7.top/posts/openapi2.0/</id><updated>2021-05-13T07:12:48+00:00</updated><published>2018-03-27T21:45:57+08:00</published><author><name>lintao</name><uri>https://lt7.top/</uri><email>mrqter@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary><content type="html">&lt;h2 id="什么是openapi规范">什么是OpenApi规范？&lt;/h2>
&lt;p>OpenApi规范是一套用语描述REST API的描述格式，分为以下几&lt;/p>
&lt;pre>&lt;code class="language-language" data-lang="language">func main() {
var a = 2
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>描述每个路径上的操作 GET POST DELETE&lt;/li>
&lt;li>请求参数和返回值&lt;/li>
&lt;li>认证方法&lt;/li>
&lt;li>联系信息，许可证，使用条款和其他信息&lt;/li>
&lt;/ul>
&lt;p>API规范可以用YAML或JSON编写。该格式对人和机器都很容易学习和阅读。&lt;/p>
&lt;p>OpenApi当前版本是3.0，本文将描述OpenApi2.0规范
可以在这里查看完整规范https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md&lt;/p>
&lt;p>本文将用一个YAML格式的例子向你描述如何编写OpenApi2.0文档&lt;/p>
&lt;h3 id="文档信息描述">文档信息描述&lt;/h3>
&lt;pre>&lt;code>swagger: &amp;quot;2.0&amp;quot;
info:
title: Sample API
description: API description in Markdown.
version: 1.0.0
host: api.example.com
basePath: /v1
schemes:
- https
&lt;/code>&lt;/pre>&lt;p>&lt;code>swagger: &amp;quot;2.0&amp;quot;&lt;/code> 说明当前使用的OpenApi版本，（Openapi 2.0是用swagger2.0标准演化而来）&lt;/p>
&lt;p>&lt;code>info&lt;/code>对象将描述本文的信息，下表是info对象的所有可用字段&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>字段&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>title&lt;/td>
&lt;td>String&lt;/td>
&lt;td>本文标题&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>description&lt;/td>
&lt;td>String&lt;/td>
&lt;td>本文的描述信息&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>termsOfService&lt;/td>
&lt;td>String&lt;/td>
&lt;td>API的服务条款&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>contact&lt;/td>
&lt;td>Object&lt;/td>
&lt;td>联系方式对象&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>license&lt;/td>
&lt;td>Object&lt;/td>
&lt;td>许可证对象&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>version&lt;/td>
&lt;td>String&lt;/td>
&lt;td>版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>contact&lt;/code> 对象用于描述本文作者联系方式&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>字段&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>name&lt;/td>
&lt;td>String&lt;/td>
&lt;td>本文作者名称&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>url&lt;/td>
&lt;td>String&lt;/td>
&lt;td>本文作者的网站&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>email&lt;/td>
&lt;td>String&lt;/td>
&lt;td>本文作者的邮件&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>license&lt;/code> 对象用于描述本文遵循的协议&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>字段&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>name&lt;/td>
&lt;td>String&lt;/td>
&lt;td>协议名称&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>url&lt;/td>
&lt;td>String&lt;/td>
&lt;td>协议URL&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>host&lt;/code> 用于描述api的服务器地址，在host中不用填写路径，但是要包括服务所用到的端口号&lt;/p>
&lt;p>&lt;code>basePath&lt;/code> 用于描述api的基础路径，例如/v1/api&lt;/p>
&lt;p>&lt;code>schemes&lt;/code> 用于描述使用的传输协议例如&lt;code>http/htttps&lt;/code>&lt;/p>
&lt;p>&lt;code>paths&lt;/code>定义了api中每个路径以及这些路径下的的操作方法（GET,POST),如果我们想在users路径下定义一个GET方法，我们可以像下面这样。&lt;/p>
&lt;pre>&lt;code>paths:
/users:
get:
tags:
- pets
summary: Returns a list of users.
description: Optional extended description in Markdown.
produces:
- application/json
responses:
200:
description: OK
&lt;/code>&lt;/pre>&lt;p>&lt;code>tags&lt;/code> 关键词可以将多个路径组成一个群组显示，我们可以在全局定义&lt;code>tags&lt;/code>关键词&lt;/p>
&lt;pre>&lt;code>tags:
- name: pets
description: Everything about your Pets
externalDocs:
url: http://docs.my-api.com/pet-operations.htm
- name: store
description: Access to Petstore orders
externalDocs:
url: http://docs.my-api.com/store-orders.htm
&lt;/code>&lt;/pre>&lt;h3 id="请求参数">请求参数&lt;/h3>
&lt;p>向服务器发起请求时我们以不同的方式提交数据给服务器，&lt;/p>
&lt;ul>
&lt;li>查询参数: /users?role=admin&lt;/li>
&lt;li>路径参数: /users/{id}&lt;/li>
&lt;li>请求头参数: X-MyHeader: Value&lt;/li>
&lt;li>Request Body 在POST或者PUT请求时上传一段JSON或者XML类型的参数&lt;/li>
&lt;li>form 参数：当Content-Type为application/x-www-form-urlencoded 或者 multipart/form-data&lt;/li>
&lt;/ul>
&lt;h5 id="路径参数">路径参数&lt;/h5>
&lt;pre>&lt;code>paths:
/users/{userId}:
get:
summary: Returns a user by ID.
parameters:
- in: path
name: userId
required: true
type: integer
minimum: 1
description: Parameter description in Markdown.
responses:
200:
description: OK
&lt;/code>&lt;/pre>&lt;h5 id="查询参数">查询参数&lt;/h5>
&lt;pre>&lt;code>paths:
/users/{userId}:
get:
parameters:
- in: query
name: offset
type: integer
description: The number of items to skip before starting to collect the result set.
- in: query
name: limit
type: integer
description: The numbers of items to return.
&lt;/code>&lt;/pre>&lt;h5 id="request-body">Request Body&lt;/h5>
&lt;p>我们可以根据&lt;code>Consumes, Produces&lt;/code>关键词描述将要传输的数据格式。例如:&lt;/p>
&lt;pre>&lt;code>consumes:
- application/json
- application/xml
produces:
- application/json
- application/xml
&lt;/code>&lt;/pre>&lt;pre>&lt;code>paths:
/users:
post:
summary: Creates a new user.
consumes:
- application/json
parameters:
- in: body
name: user
description: The user to create.
schema:
type: object
required:
- userName
properties:
userName:
type: string
firstName:
type: string
lastName:
type: string
responses:
201:
description: Created
&lt;/code>&lt;/pre>&lt;h5 id="请求头参数">请求头参数&lt;/h5>
&lt;pre>&lt;code>paths:
/ping:
get:
summary: Checks if the server is alive.
parameters:
- in: header
name: X-Request-ID
type: string
required: true
&lt;/code>&lt;/pre>&lt;h5 id="form参数">Form参数&lt;/h5>
&lt;pre>&lt;code>paths:
/survey:
post:
summary: A sample survey.
consumes:
- application/x-www-form-urlencoded
parameters:
- in: formData
name: name
type: string
description: A person's name.
- in: formData
name: fav_number
type: number
description: A person's favorite number.
responses:
200:
description: OK
&lt;/code>&lt;/pre>&lt;p>在同一个路径下定义不同的方法&lt;/p>
&lt;pre>&lt;code>paths:
/user/{id}:
parameters:
- in: path
name: id
type: integer
required: true
description: The user ID.
get:
summary: Gets a user by ID.
patch:
summary: Updates an existing user with the specified ID.
delete:
summary: Deletes the user with the specified ID.
&lt;/code>&lt;/pre>&lt;p>在定义参数时我们可以将某个参数定义为是否可选通过&lt;code>required: true&lt;/code>,参数的默认值&lt;code>default: 0&lt;/code>,我们还可以定义参数值的范围 &lt;code>minimum: 1 maximum: 100&lt;/code>&lt;/p>
&lt;h3 id="响应">响应&lt;/h3>
&lt;p>&lt;code>responses&lt;/code>对象用于定义响应的内容，响应包括Response Body，HTTP Status Codes，Response Headers,每一个API都必须有一个responses，最基础的定义如下:&lt;/p>
&lt;pre>&lt;code>paths:
/ping:
get:
produces:
- application/json
responses:
200:
description: OK
&lt;/code>&lt;/pre>&lt;h5 id="http-status-codes">HTTP Status Codes&lt;/h5>
&lt;pre>&lt;code>
responses:
200:
description: OK
400:
description: Bad request. User ID must be an integer and bigger than 0.
401:
description: Authorization information is missing or invalid.
404:
description: A user with the specified ID was not found.
&lt;/code>&lt;/pre>&lt;h5 id="response-body">Response Body&lt;/h5>
&lt;pre>&lt;code>responses:
200:
description: A User object
schema:
type: object
properties:
id:
type: integer
description: The user ID.
username:
type: string
description: The user name.
&lt;/code>&lt;/pre>&lt;h5 id="response-header">Response Header&lt;/h5>
&lt;pre>&lt;code>
paths:
/ping:
get:
summary: Checks if the server is alive.
responses:
200:
description: OK
headers:
X-RateLimit-Limit:
type: integer
description: Request limit per hour.
X-RateLimit-Remaining:
type: integer
description: The number of requests left for the time window.
X-RateLimit-Reset:
type: string
format: date-time
description: The UTC date/time at which the current rate limit window resets.
&lt;/code>&lt;/pre>&lt;h3 id="对象重用">对象重用&lt;/h3>
&lt;p>我们可以通过全局关键词&lt;code>definitions&lt;/code> 定义一个可重用的对象，然后使用&lt;code>$ref&lt;/code>引用这个对象,例如:&lt;/p>
&lt;pre>&lt;code>paths:
/users:
post:
summary: Creates a new user.
consumes:
- application/json
parameters:
- in: body
name: user
description: The user to create.
schema:
$ref: &amp;quot;#/definitions/User&amp;quot; # &amp;lt;----------
responses:
200:
description: OK
definitions:
User: # &amp;lt;----------
type: object
required:
- userName
properties:
userName:
type: string
firstName:
type: string
lastName:
type: string
&lt;/code>&lt;/pre>&lt;p>我们也可以在响应中这样使用&lt;/p>
&lt;pre>&lt;code>paths:
/users:
get:
summary: Gets a list of users.
response:
200:
description: OK
schema:
$ref: &amp;quot;#/definitions/ArrayOfUsers&amp;quot;
401:
$ref: &amp;quot;#/responses/Unauthorized&amp;quot; # &amp;lt;-----
/users/{id}:
get:
summary: Gets a user by ID.
response:
200:
description: OK
schema:
$ref: &amp;quot;#/definitions/User&amp;quot;
401:
$ref: &amp;quot;#/responses/Unauthorized&amp;quot; # &amp;lt;-----
404:
$ref: &amp;quot;#/responses/NotFound&amp;quot; # &amp;lt;-----
# Descriptions of common responses
responses:
NotFound:
description: The specified resource was not found
schema:
$ref: &amp;quot;#/definitions/Error&amp;quot;
Unauthorized:
description: Unauthorized
schema:
$ref: &amp;quot;#/definitions/Error&amp;quot;
definitions:
# Schema for error response body
Error:
type: object
properties:
code:
type: string
message:
type: string
required:
- code
- message
&lt;/code>&lt;/pre>&lt;p>在定义对象时我们可以对属性添加一个示例值&lt;/p>
&lt;p>对象&lt;/p>
&lt;pre>&lt;code>definitions:
CatalogItem:
id:
type: integer
example: 38
title:
type: string
example: T-shirt
image:
type: object
properties:
url:
type: string
width:
type: integer
height:
type: integer
required:
- url
example: # &amp;lt;-----
url: images/38.png
width: 100
height: 100
required:
- id
- title
&lt;/code>&lt;/pre>&lt;p>数组&lt;/p>
&lt;pre>&lt;code>definitions:
ArrayOfStrings:
type: array
items:
type: string
example:
- foo
- bar
- baz
&lt;/code>&lt;/pre>&lt;p>数组中嵌套的对象可以直接引用另一个已经定义好的对象&lt;/p>
&lt;pre>&lt;code>definitions:
ArrayOfCatalogItems:
type: array
items:
$ref: &amp;quot;#/definitions/CatalogItem&amp;quot;
example:
- id: 38
title: T-shirt
- id: 114
title: Phone
&lt;/code>&lt;/pre></content></entry><entry><title type="text">Golang 通过Gitlab持续集成/持续部署（CI/CD</title><link rel="alternate" type="text/html" href="http://lt7.top/posts/golang%E9%80%9A%E8%BF%87gitlab-cicd/"/><id>http://lt7.top/posts/golang%E9%80%9A%E8%BF%87gitlab-cicd/</id><updated>2021-05-13T07:12:48+00:00</updated><published>2018-03-16T14:52:41+08:00</published><author><name>lintao</name><uri>https://lt7.top/</uri><email>mrqter@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary><content type="html">&lt;p>gitlab自带的CI工具可以非常简单的实现持续集成和持续部署，无需繁琐的安装。
工作流程:
将代码提交到gitlab-&amp;gt;gitlab进入CI工作流-&amp;gt;GitLab-Runner从gitlab代码服务器拉下最新代码，根据.gitlab-ci.yml执行PIPELINE,
&lt;img src="media/15211786315251.png" alt="">&lt;/p>
&lt;h1 id="安装gitlab-runner">安装GitLab-Runner:&lt;/h1>
&lt;p>&lt;a href="https://docs.gitlab.com/runner/#install-gitlab-runner">https://docs.gitlab.com/runner/#install-gitlab-runner&lt;/a>&lt;/p>
&lt;p>将这个Runner注册到你运行的Gitlab实例上,这样你的代码每次发生变化Gitlab就会通知这个Runner来执行CI流程，打开项目的Settings-&amp;gt;CI/CD-&amp;gt;Runners settings,找到Specific Runners下面的Gitlab服务器地址和Token
&lt;img src="media/15211798850111.jpg" alt="">&lt;/p>
&lt;p>&lt;a href="https://docs.gitlab.com/runner/#install-gitlab-runner">https://docs.gitlab.com/runner/#install-gitlab-runner&lt;/a>
运行以下命令执行注册&lt;/p>
&lt;pre>&lt;code>sudo gitlab-runner register
&lt;/code>&lt;/pre>&lt;p>输入你的GitLab实例URL：&lt;/p>
&lt;pre>&lt;code>Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )
xxx
&lt;/code>&lt;/pre>&lt;p>输入您获得的注册Runner的token：&lt;/p>
&lt;pre>&lt;code>Please enter the gitlab-ci token for this runner
xxx
&lt;/code>&lt;/pre>&lt;p>输入Runner的描述，你可以稍后在GitLab的用户界面中进行更改：&lt;/p>
&lt;pre>&lt;code>Please enter the gitlab-ci description for this runner
my-runner
&lt;/code>&lt;/pre>&lt;p>输入与Runner关联的标签，稍后可以在GitLab的用户界面中进行更改：&lt;/p>
&lt;pre>&lt;code>Please enter the gitlab-ci tags for this runner (comma separated):
go
&lt;/code>&lt;/pre>&lt;p>选择Runner是否应该选择没有标签的作业，以后可以在GitLab的用户界面中更改它（默认为false）：&lt;/p>
&lt;pre>&lt;code>Whether to run untagged jobs [true/false]:
true
&lt;/code>&lt;/pre>&lt;p>选择是否将Runner锁定到当前项目，您可以稍后在GitLab的用户界面中进行更改。Runner特定时有用（默认为true）：&lt;/p>
&lt;pre>&lt;code>Whether to lock Runner to current project [true/false]:
true
&lt;/code>&lt;/pre>&lt;p>输入Runner执行者：
如果您选择Docker作为您的执行程序，则会要求您为默认图像用于未在其中定义一个的项目.gitlab-ci.yml&lt;/p>
&lt;pre>&lt;code>Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:
docker
&lt;/code>&lt;/pre>&lt;p>编辑.gitlab-ci.yml文件, 这里使用docker运行环境，省去了构建编译环境的麻烦。&lt;/p>
&lt;pre>&lt;code>image: golang:latest
variables:
REPO_NAME: project
before_script:
- mkdir -p $GOPATH/src/$(dirname $REPO_NAME)
- ln -svf $CI_PROJECT_DIR $GOPATH/src/$REPO_NAME
- cd $GOPATH/src/$REPO_NAME
&lt;/code>&lt;/pre>&lt;p>&lt;code>image: golang:latest&lt;/code>这里告诉Runner将代码运行在哪个容器内运行。&lt;code>variables: REPO_NAME: project&lt;/code> 配置变量，跟shell里的变量是一个意思。&lt;code>before_script&lt;/code>在执行所有步骤之前执行的一段脚本。这里我们在go/src/目录下根据项目名称创建了一个文件夹，然后从$CI_PROJECT_DIR环境变量获取到代码现在存在的目录，将目录建立一个软链接链接到刚刚创建的go/src/project目录。这样我们就完成了go编译环境的搭建，&lt;/p>
&lt;pre>&lt;code>stages:
- test
- build
- deploy
&lt;/code>&lt;/pre>&lt;p>stages 用于定义执行步骤，每个步骤可以在job中使用。stages的排序定义了Job执行的顺序：
根据上面定义。首先所有被定义为test的job会并行执行，如果所有的test都执行成功了然后就会执行所有定义为build的job.如果任何先前的Job失败，则提交被标记为failed并且不执行下一步&lt;/p>
&lt;pre>&lt;code>test:
stage: test
script:
- cd tests
- go test -v
compile:
stage: build
script:
- go build -o $CI_PROJECT_DIR/demo
artifacts:
paths:
- demo
deploy_develop:
stage: deploy
script:
- echo &amp;quot;$SSH_PRIVATE_KEY&amp;quot; &amp;gt;&amp;gt; ~/.ssh/id_dsa
- chmod 600 ~/.ssh/id_dsa
- echo -e &amp;quot;Host *\n\tStrictHostKeyChecking no\n\n&amp;quot; &amp;gt; ~/.ssh/config
- rsync $CI_PROJECT_DIR/demo root@xxxx:/root/program
- ssh root@xxxx &amp;quot;/usr/bin/supervisorctl restart demo&amp;quot;
only:
- develop
deploy_production:
stage: deploy
script:
- echo &amp;quot;$SSH_PRIVATE_KEY&amp;quot; &amp;gt;&amp;gt; ~/.ssh/id_dsa
- chmod 600 ~/.ssh/id_dsa
- echo -e &amp;quot;Host *\n\tStrictHostKeyChecking no\n\n&amp;quot; &amp;gt; ~/.ssh/config
- rsync $CI_PROJECT_DIR/demo root@xxxx:/root/program
- ssh root@xxxx &amp;quot;/usr/bin/supervisorctl restart demo&amp;quot;
only:
- master
&lt;/code>&lt;/pre>&lt;p>这里定义了4个job分别是test,compile,deploy_production,deploy_develop,首先我们执行测试，测试成功后编译出一个可执行文件，然后根据不同的提交分支发布到不同的服务器上部署&lt;/p>
&lt;p>fatal: repository 'http://gitlab-ci-token:xxxxxxxxxxxxxxxxxxxx@192.168.15.95/lintao/work-doc.git/' not found
错误处理
vim /etc/gitlab-runner/config.toml
clone_url = &amp;quot;http://192.168.15.95:8080/&amp;quot;&lt;/p>
&lt;p>FROM golang:latest&lt;/p>
&lt;p>RUN apt-get update -y &amp;amp;&amp;amp; apt-get install openssh-client -y &amp;amp;&amp;amp; apt-get update -y &amp;amp;&amp;amp; apt-get install rsync -y &amp;amp;&amp;amp; mkdir -p ~/.ssh&lt;/p></content></entry><entry><title type="text">Mac安装Gitlab</title><link rel="alternate" type="text/html" href="http://lt7.top/posts/mac%E5%AE%89%E8%A3%85gitlab/"/><id>http://lt7.top/posts/mac%E5%AE%89%E8%A3%85gitlab/</id><updated>2021-05-13T07:12:48+00:00</updated><published>2018-02-22T22:53:00+08:00</published><author><name>lintao</name><uri>https://lt7.top/</uri><email>mrqter@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary><content type="html">&lt;p>安装环境:
Docker
&lt;a href="https://hub.docker.com/r/twang2218/gitlab-ce-zh/">Gitlab中文镜像&lt;/a>
4GB内存&lt;/p>
&lt;p>Docker安装:&lt;/p>
&lt;p>Mac版本下载地址
&lt;a href="https://store.docker.com/editions/community/docker-ce-desktop-mac">https://store.docker.com/editions/community/docker-ce-desktop-mac&lt;/a>&lt;/p>
&lt;p>下载完docker后添加Daocloud加速器
&lt;a href="http://www.daocloud.io/mirror#accelerator-doc">http://www.daocloud.io/mirror#accelerator-doc&lt;/a>&lt;/p>
&lt;p>&lt;img src="http://7u2kla.com1.z0.glb.clouddn.com/%E5%8A%A0%E9%80%9F%E5%99%A8_DaoCloud_-_%E4%B8%9A%E7%95%8C%E9%A2%86%E5%85%88%E7%9A%84%E5%AE%B9%E5%99%A8%E4%BA%91%E5%B9%B3%E5%8F%B0.png" alt="加速器_DaoCloud_-_业界领先的容器云平台">&lt;/p>
&lt;p>下载中文版Gitlab镜像&lt;/p>
&lt;pre>&lt;code>docker pull twang2218/gitlab-ce-zh
&lt;/code>&lt;/pre>&lt;p>启动容器:&lt;/p>
&lt;pre>&lt;code>docker run -d \
--hostname gitlab.example.com \
-p 80:80 \
-p 443:443 \
-p 22:22 \
--name gitlab \
--restart unless-stopped \
-v gitlab-config:/etc/gitlab \
-v gitlab-logs:/var/log/gitlab \
-v gitlab-data:/var/opt/gitlab \
--network gitlab-net \
twang2218/gitlab-ce-zh:10.4.3
&lt;/code>&lt;/pre>&lt;p>进入容器修改配置&lt;/p>
&lt;pre>&lt;code>docker exec -it gitlab bash
vi /etc/gitlab/gitlab.rb
&lt;/code>&lt;/pre>&lt;p>修改时区&lt;/p>
&lt;pre>&lt;code> gitlab_rails['time_zone'] = 'Asia/Shanghai'
&lt;/code>&lt;/pre>&lt;p>配置邮箱:&lt;/p>
&lt;pre>&lt;code>### Email Settings
gitlab_rails['smtp_enable'] = true
gitlab_rails['smtp_address'] = &amp;quot;smtp.qq.com&amp;quot;
gitlab_rails['smtp_port'] = 465
gitlab_rails['smtp_user_name'] = &amp;quot;xxxx@qq.com&amp;quot;
gitlab_rails['smtp_password'] = &amp;quot;xxxx&amp;quot;
gitlab_rails['smtp_authentication'] = &amp;quot;login&amp;quot;
gitlab_rails['smtp_enable_starttls_auto'] = true
gitlab_rails['smtp_tls'] = true
gitlab_rails['gitlab_email_from'] = 'xxxx@qq.com'
&lt;/code>&lt;/pre>&lt;p>修改完后更新下配置，&lt;a href="https://docs.gitlab.com/omnibus/settings/smtp.html">更多邮箱配置参考&lt;/a>&lt;/p>
&lt;pre>&lt;code>gitlab-ctl reconfigure
&lt;/code>&lt;/pre>&lt;p>在浏览器打开http://127.0.0.1 首次安装会要几分钟初始化。可能会出现500的情况，初始化完成后就能使用了。
&lt;img src="http://7u2kla.com1.z0.glb.clouddn.com/%E6%98%9F%E6%A0%87%E9%A1%B9%E7%9B%AE_%C2%B7_%E4%BB%AA%E8%A1%A8%E7%9B%98_%C2%B7_GitLab_%E5%92%8C_2018-02-22_md.png" alt="星标项目_·_仪表盘_·_GitLab_和_2018-02-22_md">&lt;/p>
&lt;p>Gitlab文档
&lt;a href="https://docs.gitlab.com/omnibus/README.html">https://docs.gitlab.com/omnibus/README.html&lt;/a>&lt;/p></content></entry><entry><title type="text">搭建Shadowsocks服务器</title><link rel="alternate" type="text/html" href="http://lt7.top/posts/%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8/"/><id>http://lt7.top/posts/%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8/</id><updated>2021-05-13T07:12:48+00:00</updated><published>2017-11-01T11:56:56+08:00</published><author><name>lintao</name><uri>https://lt7.top/</uri><email>mrqter@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary><content type="html">&lt;p>最近VPN总是掉线连不上，所以决定自己搭建一个Shadowsocks服务器,找了各种教程后发现搭建Shadowsocks服务器非常简单
搭建Shadowsocks需要一个在墙外的服务器。
###VPS
免费：
亚马逊有免费1年的vps服务器，只需要绑定信用卡就可以了。
付费：
&lt;a href="https://www.vultr.com">https://www.vultr.com&lt;/a>
&lt;a href="https://bandwagonhost.com/cart.php">https://bandwagonhost.com/cart.php&lt;/a>
&lt;a href="https://bandwagonhost.com">https://bandwagonhost.com&lt;/a>
&lt;a href="https://www.linode.com">https://www.linode.com&lt;/a>&lt;/p>
&lt;p>如果对网速有要求只能选香港的vps,看youtube 4K无压力，平时只是用用google推荐使用vultr。创建服务器前最好先测试下网速。&lt;/p>
&lt;p>linode
&lt;a href="https://www.linode.com/speedtest">https://www.linode.com/speedtest&lt;/a>
vultr 打开网页后搜索How can I test Vultr download speeds?
&lt;a href="https://www.vultr.com/faq/">https://www.vultr.com/faq/&lt;/a>&lt;/p>
&lt;p>###安装GO
首先在官网找到最新二进制版本的连接
&lt;a href="https://golang.org/dl/">https://golang.org/dl/&lt;/a>&lt;/p>
&lt;p>####下载二进制包
&lt;code>wget https://storage.googleapis.com/golang/go1.8.1.linux-amd64.tar.gz&lt;/code>&lt;/p>
&lt;p>####解压到Local目录下&lt;/p>
&lt;p>&lt;code>sudo tar -xzf go1.8.1.linux-amd64.tar.gz -C /usr/local&lt;/code>&lt;/p>
&lt;p>####设置环境变量&lt;/p>
&lt;p>&lt;code>vim /etc/profile&lt;/code>&lt;/p>
&lt;pre>&lt;code>export PATH=$PATH:/usr/local/go/bin
export GOPATH=$HOME/work
export PATH=$GOPATH/bin:$PATH
&lt;/code>&lt;/pre>&lt;p>&lt;code>source /etc/profile&lt;/code>&lt;/p>
&lt;p>###安装supervisor
&lt;code>apt-get -y install supervisor&lt;/code>&lt;/p>
&lt;p>&lt;code>vim /etc/supervisor/conf.d/shadowsocks.conf&lt;/code>&lt;/p>
&lt;pre>&lt;code>[program:shadowsocks]
command=/root/work/bin/shadowsocks-server -c config.json
directory=/root
autostart=true
autorestart=true
&lt;/code>&lt;/pre>&lt;p>###安装Go版本shadowsocks
&lt;code>go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server&lt;/code>&lt;/p>
&lt;p>####创建配置文件
&lt;code>vim config.json&lt;/code>
####参数&lt;/p>
&lt;pre>&lt;code>server vps公网ip
server_port 服务器端口， 需要在安全组里打开这个端口，不然客户端无法访问
local_port 本地socks5代理端口
method 加密方式,下面是所有支持的加密方式:
aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, chacha20, salsa20, rc4,
password 用于加密传输的密码r
timeout 超时设置，以秒为单位
&lt;/code>&lt;/pre>&lt;pre>&lt;code>{
&amp;quot;server&amp;quot;:&amp;quot;xxx.xxx.xxx.xx&amp;quot;,
&amp;quot;server_port&amp;quot;:2333,
&amp;quot;local_port&amp;quot;:1080,
&amp;quot;password&amp;quot;:&amp;quot;123456&amp;quot;,
&amp;quot;timeout&amp;quot;:60,
&amp;quot;method&amp;quot;:&amp;quot;aes-256-cfb&amp;quot;
}
&lt;/code>&lt;/pre>&lt;p>Mac os使用
首先下载客户端,NG是最新版的功能比较多。&lt;/p>
&lt;pre>&lt;code>https://sourceforge.net/projects/shadowsocksgui/?source=typ_redirect
&lt;/code>&lt;/pre>&lt;pre>&lt;code>https://github.com/shadowsocks/ShadowsocksX-NG/releases/download/v1.6.1/ShadowsocksX-NG.1.6.1.zip
&lt;/code>&lt;/pre>&lt;p>iOS推荐使用Wingy，非常方便的小工具
&lt;img src="http://7u2kla.com1.z0.glb.clouddn.com/15101075736153.jpg" alt="">&lt;/p>
&lt;p>linux上使用
先下载客户端程序。然后编辑config文件&lt;/p>
&lt;pre>&lt;code>go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local
&lt;/code>&lt;/pre>&lt;pre>&lt;code>{
&amp;quot;server&amp;quot;:&amp;quot;xx.xx.xx.xx&amp;quot;, 服务器地址
&amp;quot;server_port&amp;quot;:8080, 服务器端口
&amp;quot;local_port&amp;quot;:1080, 本地监听的端口
&amp;quot;password&amp;quot;:&amp;quot;123456&amp;quot;,
&amp;quot;method&amp;quot;: &amp;quot;aes-128-cfb-auth&amp;quot;,
&amp;quot;timeout&amp;quot;:600
}
&lt;/code>&lt;/pre>&lt;p>在后台启动这个服务
&lt;code>nohup ./shadowsocks-local config.json &amp;amp;&lt;/code>&lt;/p>
&lt;p>在linux上使用需要浏览器设置好代理方式。以firefox为例;
先安装AutoProxy-ng插件
&lt;img src="http://7u2kla.com1.z0.glb.clouddn.com/15101081468737.jpg" alt="">&lt;/p></content></entry><entry><title type="text">Mysql配置主从同步</title><link rel="alternate" type="text/html" href="http://lt7.top/posts/mysql%E9%85%8D%E7%BD%AE%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/><id>http://lt7.top/posts/mysql%E9%85%8D%E7%BD%AE%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</id><updated>2021-05-13T07:12:48+00:00</updated><published>2017-11-01T10:07:29+08:00</published><author><name>lintao</name><uri>https://lt7.top/</uri><email>mrqter@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary><content type="html">&lt;p>参考
&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/replication.html">Mysql官方文档&lt;/a>&lt;/p>
&lt;p>##主机配置:&lt;/p>
&lt;p>&lt;strong>修改My.conf&lt;/strong>&lt;/p>
&lt;p>&lt;code>server-id = 1&lt;/code>
主机Id
&lt;code>log_bin = mast-binlog&lt;/code>
binlog存放位置
&lt;code>log-bin-index = master-binlog.index&lt;/code>
存放binlog索引
&lt;code>expire_logs_days = 10&lt;/code>
binlog过期时间
&lt;code>max_binlog_size = 200M&lt;/code>
binlog文件大小
&lt;code>binlog_do_db = database&lt;/code>
binlog只对那些库启用&lt;/p>
&lt;p>确保skip-networking主服务器上未启用该选项。如果网络被禁用，则从机不能与主机通信，并且复制失败。
确保bind-address主机上没有启用改选项或者修改成0.0.0.0&lt;/p>
&lt;p>log_bin和log-bin-index可以自定义存储目录。修改默认存储路径时需要修改mysql的访问权限。&lt;/p>
&lt;pre>&lt;code>vim /etc/apparmor.d/usr.sbin.mysqld
&lt;/code>&lt;/pre>&lt;p>配置好My.conf和apparmor后需要重启配置才能生效&lt;/p>
&lt;p>在主机上创建一个用户给从机连接&lt;/p>
&lt;pre>&lt;code>CREATE USER 'slave_mysql'@'%' IDENTIFIED BY 'mmp123';
GRANT REPLICATION SLAVE ON *.* TO 'slave_mysql'@'%';
&lt;/code>&lt;/pre>&lt;p>创建完用户有刷新权限
&lt;code>flush privileges;&lt;/code>&lt;/p>
&lt;p>锁住数据库用mysqldump将这个数据库备份发给从机，配置好从机再解锁&lt;/p>
&lt;pre>&lt;code>FLUSH TABLES WITH READ LOCK;
UNLOCK TABLES;
&lt;/code>&lt;/pre>&lt;p>查看主机当前在用哪个binlog文件写入和写入位置&lt;/p>
&lt;p>&lt;code>SHOW MASTER STATUS;&lt;/code>&lt;/p>
&lt;pre>&lt;code>File postion Binglog-Do-DB
master-bin.00001 004 database
&lt;/code>&lt;/pre>&lt;p>从机配置&lt;/p>
&lt;p>&lt;strong>修改My.conf&lt;/strong>&lt;/p>
&lt;pre>&lt;code>
```server-id = 2```
从机ID不能和主机一样
```replicate-do-db=database```
需要备份那些库
```relay_log = server-relay-bin```
中继日志存放位置。从机从主机获取数据后先会放入中继日志，然后从中继中读取sql语句。
配置好my.conf后重启从机，然后在从机配置主机信息
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/change-master-to.html">CHANGE MASTER TO 完整语法介绍&lt;/a>&lt;/p>
&lt;p>从机配置
&lt;a href="https://mysql.az/2015/04/12/change-binary-log-and-relay-log-location-to-home/">https://mysql.az/2015/04/12/change-binary-log-and-relay-log-location-to-home/&lt;/a>&lt;/p>
&lt;p>查看Binlog
binlog无法查看解决办法
mysqlbinlog: [ERROR] unknown variable 'default-character-set=utf8'
mysqlbinlog --no-defaults --set-charset=utf8 master-bin.080541
查看Row模式下的binlog
mysqlbinlog --no-defaults --set-charset=utf8 -v --base64-output=DECODE-ROWS master-bin.080541&lt;/p>
&lt;p>&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/mysqlbinlog-row-events.html">https://dev.mysql.com/doc/refman/5.7/en/mysqlbinlog-row-events.html&lt;/a>&lt;/p>
&lt;p>创建过滤规则
CHANGE REPLICATION FILTER filter[, filter][, ...]&lt;/p>
&lt;p>filter:
REPLICATE_DO_DB = (db_list)
| REPLICATE_IGNORE_DB = (db_list)
| REPLICATE_DO_TABLE = (tbl_list)
| REPLICATE_IGNORE_TABLE = (tbl_list)
| REPLICATE_WILD_DO_TABLE = (wild_tbl_list)
| REPLICATE_WILD_IGNORE_TABLE = (wild_tbl_list)
| REPLICATE_REWRITE_DB = (db_pair_list)&lt;/p>
&lt;p>CHANGE REPLICATION FILTER
REPLICATE_IGNORE_TABLE = ()&lt;/p>
&lt;p>db_list:
db_name[, db_name][, ...]&lt;/p>
&lt;p>tbl_list:
db_name.table_name[, db_table_name][, ...]
wild_tbl_list:
'db_pattern.table_pattern'[, 'db_pattern.table_pattern'][, ...]&lt;/p>
&lt;p>db_pair_list:
(db_pair)[, (db_pair)][, ...]&lt;/p>
&lt;p>db_pair:
from_db, to_db&lt;/p>
&lt;pre>&lt;code>CHANGE REPLICATION FILTER
&lt;/code>&lt;/pre>
&lt;p>REPLICATE_WILD_IGNORE_TABLE = ('db1.new%', 'db2.new%');&lt;/p>
&lt;p>日志清理
PURGE MASTER LOGS BEFORE DATE_SUB(CURRENT_DATE, INTERVAL 2 DAY)
&lt;a href="http://www.ttlsa.com/mysql/mysql-5-7-enhanced-multi-thread-salve/">http://www.ttlsa.com/mysql/mysql-5-7-enhanced-multi-thread-salve/&lt;/a>
从机开启多线程
STOP SLAVE;
SET GLOBAL master_info_repository = 'TABLE'
SET GLOBAL relay_log_info_repository = 'TABLE'
SET GLOBAL relay_log_recovery =
SET GLOBAL slave_parallel_type=LOGICAL_CLOCK;
&lt;br>
START slave&lt;/p>
&lt;p>&lt;a href="https://www.percona.com/blog/2013/02/08/how-to-createrestore-a-slave-using-gtid-replication-in-mysql-5-6/">https://www.percona.com/blog/2013/02/08/how-to-createrestore-a-slave-using-gtid-replication-in-mysql-5-6/&lt;/a>&lt;/p>
&lt;p>同步出错解决方案
The slave is connecting using CHANGE MASTER TO MASTER_AUTO_POSITION = 1, but the master has purged binary logs containing GTIDs that the slave requires.&lt;/p>
&lt;p>这个是由于在主库上执行过purge binary logs，然后当从库change master的时候，却要执行那些事务。
你可以在主库上先查找哪些gtid被purge了。
show global variables like 'gtid_purged';
然后拿着这个value，去从库上依次
stop slave;
set global gtid_purged = 'xxx'; # xxx是你主库上查到的value。
start slave;
这样能跳过执行被主库已经purge的事务了。
如果出现
@@GLOBAL.GTID_PURGED can only be set when @@GLOBAL.GTID_EXECUTED is empty.
reset master后在执行&lt;/p></content></entry></feed>