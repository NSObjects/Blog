<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title type="text">Gopher</title>
    <subtitle type="html">Gopher</subtitle>
    <updated>2021-05-13T14:54:51&#43;08:00</updated>
    <id>http://lt7.top/</id>
    <link rel="alternate" type="text/html" href="http://lt7.top/" />
    <link rel="self" type="application/atom&#43;xml" href="http://lt7.top/atom.xml" />
    <author>
            <name>lintao</name>
            <uri>http://lt7.top/</uri>
            
                <email>mrqter@gmail.com</email>
            </author>
    <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    <generator uri="https://gohugo.io/" version="0.82.0">Hugo</generator>
        <entry>
            <title type="text">OpenApi2.0</title>
            <link rel="alternate" type="text/html" href="http://lt7.top/posts/openapi2.0/" />
            <id>http://lt7.top/posts/openapi2.0/</id>
            <updated>2021-05-13T10:03:57&#43;08:00</updated>
            <published>2018-03-27T21:45:57&#43;08:00</published>
            <author>
                    <name>lintao</name>
                    <uri>https://lt7.top/</uri>
                    <email>mrqter@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary>
            
                <content type="html">&lt;h2 id=&#34;什么是openapi规范&#34;&gt;什么是OpenApi规范？&lt;/h2&gt;
&lt;p&gt;OpenApi规范是一套用语描述REST API的描述格式，分为以下几&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language&#34; data-lang=&#34;language&#34;&gt;func main() {
 var a = 2
}
 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;描述每个路径上的操作 GET POST DELETE&lt;/li&gt;
&lt;li&gt;请求参数和返回值&lt;/li&gt;
&lt;li&gt;认证方法&lt;/li&gt;
&lt;li&gt;联系信息，许可证，使用条款和其他信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;API规范可以用YAML或JSON编写。该格式对人和机器都很容易学习和阅读。&lt;/p&gt;
&lt;p&gt;OpenApi当前版本是3.0，本文将描述OpenApi2.0规范
可以在这里查看完整规范https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md&lt;/p&gt;
&lt;p&gt;本文将用一个YAML格式的例子向你描述如何编写OpenApi2.0文档&lt;/p&gt;
&lt;h3 id=&#34;文档信息描述&#34;&gt;文档信息描述&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;swagger: &amp;quot;2.0&amp;quot;
info:
  title: Sample API
  description: API description in Markdown.
  version: 1.0.0

host: api.example.com
basePath: /v1
schemes:
  - https
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;swagger: &amp;quot;2.0&amp;quot;&lt;/code&gt; 说明当前使用的OpenApi版本，（Openapi 2.0是用swagger2.0标准演化而来）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;info&lt;/code&gt;对象将描述本文的信息，下表是info对象的所有可用字段&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;title&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;本文标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;description&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;本文的描述信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;termsOfService&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;API的服务条款&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;contact&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;联系方式对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;license&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;许可证对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;version&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;版本&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;contact&lt;/code&gt; 对象用于描述本文作者联系方式&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;本文作者名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;url&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;本文作者的网站&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;email&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;本文作者的邮件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;license&lt;/code&gt; 对象用于描述本文遵循的协议&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;协议名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;url&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;协议URL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;host&lt;/code&gt; 用于描述api的服务器地址，在host中不用填写路径，但是要包括服务所用到的端口号&lt;/p&gt;
&lt;p&gt;&lt;code&gt;basePath&lt;/code&gt; 用于描述api的基础路径，例如/v1/api&lt;/p&gt;
&lt;p&gt;&lt;code&gt;schemes&lt;/code&gt; 用于描述使用的传输协议例如&lt;code&gt;http/htttps&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;paths&lt;/code&gt;定义了api中每个路径以及这些路径下的的操作方法（GET,POST),如果我们想在users路径下定义一个GET方法，我们可以像下面这样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;paths:
  /users:
    get:
      tags:
        - pets
      summary: Returns a list of users.
      description: Optional extended description in Markdown.
      produces:
        - application/json
      responses:
        200:
          description: OK
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;tags&lt;/code&gt; 关键词可以将多个路径组成一个群组显示，我们可以在全局定义&lt;code&gt;tags&lt;/code&gt;关键词&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tags:
  - name: pets
    description: Everything about your Pets
    externalDocs:
      url: http://docs.my-api.com/pet-operations.htm
  - name: store
    description: Access to Petstore orders
    externalDocs:
      url: http://docs.my-api.com/store-orders.htm
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;请求参数&#34;&gt;请求参数&lt;/h3&gt;
&lt;p&gt;向服务器发起请求时我们以不同的方式提交数据给服务器，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询参数: /users?role=admin&lt;/li&gt;
&lt;li&gt;路径参数: /users/{id}&lt;/li&gt;
&lt;li&gt;请求头参数: X-MyHeader: Value&lt;/li&gt;
&lt;li&gt;Request Body 在POST或者PUT请求时上传一段JSON或者XML类型的参数&lt;/li&gt;
&lt;li&gt;form 参数：当Content-Type为application/x-www-form-urlencoded 或者 multipart/form-data&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;路径参数&#34;&gt;路径参数&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;paths:
  /users/{userId}:
    get:
      summary: Returns a user by ID.
      parameters:
        - in: path
          name: userId
          required: true
          type: integer
          minimum: 1
          description: Parameter description in Markdown.
      responses:
        200:
          description: OK
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;查询参数&#34;&gt;查询参数&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;paths:
  /users/{userId}:
    get:
        parameters:
            - in: query
            name: offset
            type: integer
            description: The number of items to skip before starting to collect the result set.
            - in: query
            name: limit
            type: integer
            description: The numbers of items to return.    
            
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;request-body&#34;&gt;Request Body&lt;/h5&gt;
&lt;p&gt;我们可以根据&lt;code&gt;Consumes, Produces&lt;/code&gt;关键词描述将要传输的数据格式。例如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;consumes:
  - application/json
  - application/xml
produces:
  - application/json
  - application/xml
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;paths:
  /users:
    post:
      summary: Creates a new user.
      consumes:
        - application/json
      parameters:
        - in: body
          name: user
          description: The user to create.
          schema:
            type: object
            required:
              - userName
            properties:
              userName:
                type: string
              firstName:
                type: string
              lastName:
                type: string
      responses:
        201:
          description: Created
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;请求头参数&#34;&gt;请求头参数&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;paths:
  /ping:
    get:
      summary: Checks if the server is alive.
      parameters:
        - in: header
          name: X-Request-ID
          type: string
          required: true
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;form参数&#34;&gt;Form参数&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;paths:
  /survey:
    post:
      summary: A sample survey.
      consumes:
        - application/x-www-form-urlencoded
      parameters:
        - in: formData
          name: name
          type: string
          description: A person&#39;s name.
        - in: formData
          name: fav_number
          type: number
          description: A person&#39;s favorite number.
      responses:
        200:
          description: OK
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在同一个路径下定义不同的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;paths:
  /user/{id}:
    parameters:
      - in: path
        name: id
        type: integer
        required: true
        description: The user ID.
    get:
      summary: Gets a user by ID.
    patch:
      summary: Updates an existing user with the specified ID.
    delete:
      summary: Deletes the user with the specified ID.

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在定义参数时我们可以将某个参数定义为是否可选通过&lt;code&gt;required: true&lt;/code&gt;,参数的默认值&lt;code&gt;default: 0&lt;/code&gt;,我们还可以定义参数值的范围 &lt;code&gt;minimum: 1 maximum: 100&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;响应&#34;&gt;响应&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;responses&lt;/code&gt;对象用于定义响应的内容，响应包括Response Body，HTTP Status Codes，Response Headers,每一个API都必须有一个responses，最基础的定义如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;paths:
  /ping:
    get:
      produces:
        - application/json
      responses:
        200:
          description: OK
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;http-status-codes&#34;&gt;HTTP Status Codes&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
responses:
        200:
          description: OK
        400:
          description: Bad request. User ID must be an integer and bigger than 0.
        401:
          description: Authorization information is missing or invalid.
        404:
          description: A user with the specified ID was not found.
          
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;response-body&#34;&gt;Response Body&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;responses:
        200:
          description: A User object
          schema:
            type: object
            properties:
              id:
                type: integer
                description: The user ID.
              username:
                type: string
                description: The user name.
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;response-header&#34;&gt;Response Header&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
paths:
  /ping:
    get:
      summary: Checks if the server is alive.
      responses:
        200:
          description: OK
          headers:
            X-RateLimit-Limit:
              type: integer
              description: Request limit per hour.
            X-RateLimit-Remaining:
              type: integer
              description: The number of requests left for the time window.
            X-RateLimit-Reset:
              type: string
              format: date-time
              description: The UTC date/time at which the current rate limit window resets.
              
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;对象重用&#34;&gt;对象重用&lt;/h3&gt;
&lt;p&gt;我们可以通过全局关键词&lt;code&gt;definitions&lt;/code&gt; 定义一个可重用的对象，然后使用&lt;code&gt;$ref&lt;/code&gt;引用这个对象,例如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;paths:
  /users:
    post:
      summary: Creates a new user.
      consumes:
        - application/json
      parameters:
        - in: body
          name: user
          description: The user to create.
          schema:
            $ref: &amp;quot;#/definitions/User&amp;quot;     # &amp;lt;----------
     responses:
         200:
           description: OK
definitions:
  User:           # &amp;lt;----------
    type: object
    required:
      - userName
    properties:
      userName:
        type: string
      firstName:
        type: string
      lastName:
        type: string
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们也可以在响应中这样使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;paths:
  /users:
    get:
      summary: Gets a list of users.
      response:
        200:
          description: OK
          schema:
            $ref: &amp;quot;#/definitions/ArrayOfUsers&amp;quot;
        401:
          $ref: &amp;quot;#/responses/Unauthorized&amp;quot;   # &amp;lt;-----
  /users/{id}:
    get:
      summary: Gets a user by ID.
      response:
        200:
          description: OK
          schema:
            $ref: &amp;quot;#/definitions/User&amp;quot;
        401:
          $ref: &amp;quot;#/responses/Unauthorized&amp;quot;   # &amp;lt;-----
        404:
          $ref: &amp;quot;#/responses/NotFound&amp;quot;       # &amp;lt;-----
# Descriptions of common responses
responses:
  NotFound:
    description: The specified resource was not found
    schema:
      $ref: &amp;quot;#/definitions/Error&amp;quot;
  Unauthorized:
    description: Unauthorized
    schema:
      $ref: &amp;quot;#/definitions/Error&amp;quot;
definitions:
  # Schema for error response body
  Error:
    type: object
    properties:
      code:
        type: string
      message:
        type: string
    required:
      - code
      - message
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在定义对象时我们可以对属性添加一个示例值&lt;/p&gt;
&lt;p&gt;对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;definitions:
  CatalogItem:
    id:
      type: integer
      example: 38
    title:
      type: string
      example: T-shirt
    image:
      type: object
      properties:
        url:
          type: string
        width:
          type: integer
        height:
          type: integer
      required:
        - url
      example:   # &amp;lt;-----
        url: images/38.png
        width: 100
        height: 100
    required:
      - id
      - title
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;definitions:
  ArrayOfStrings:
    type: array
    items:
      type: string
    example:
      - foo
      - bar
      - baz
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数组中嵌套的对象可以直接引用另一个已经定义好的对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;definitions:
  ArrayOfCatalogItems:
    type: array
    items:
      $ref: &amp;quot;#/definitions/CatalogItem&amp;quot;
    example:
      - id: 38
        title: T-shirt
      - id: 114
        title: Phone
&lt;/code&gt;&lt;/pre&gt;</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Golang 通过Gitlab持续集成/持续部署（CI/CD</title>
            <link rel="alternate" type="text/html" href="http://lt7.top/posts/golang%E9%80%9A%E8%BF%87gitlab-cicd/" />
            <id>http://lt7.top/posts/golang%E9%80%9A%E8%BF%87gitlab-cicd/</id>
            <updated>2021-05-13T10:03:57&#43;08:00</updated>
            <published>2018-03-16T14:52:41&#43;08:00</published>
            <author>
                    <name>lintao</name>
                    <uri>https://lt7.top/</uri>
                    <email>mrqter@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary>
            
                <content type="html">&lt;p&gt;gitlab自带的CI工具可以非常简单的实现持续集成和持续部署，无需繁琐的安装。
工作流程:
将代码提交到gitlab-&amp;gt;gitlab进入CI工作流-&amp;gt;GitLab-Runner从gitlab代码服务器拉下最新代码，根据.gitlab-ci.yml执行PIPELINE,
&lt;img src=&#34;media/15211786315251.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;安装gitlab-runner&#34;&gt;安装GitLab-Runner:&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.gitlab.com/runner/#install-gitlab-runner&#34;&gt;https://docs.gitlab.com/runner/#install-gitlab-runner&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将这个Runner注册到你运行的Gitlab实例上,这样你的代码每次发生变化Gitlab就会通知这个Runner来执行CI流程，打开项目的Settings-&amp;gt;CI/CD-&amp;gt;Runners settings,找到Specific Runners下面的Gitlab服务器地址和Token
&lt;img src=&#34;media/15211798850111.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.gitlab.com/runner/#install-gitlab-runner&#34;&gt;https://docs.gitlab.com/runner/#install-gitlab-runner&lt;/a&gt;
运行以下命令执行注册&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo gitlab-runner register
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输入你的GitLab实例URL：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )
xxx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输入您获得的注册Runner的token：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Please enter the gitlab-ci token for this runner
xxx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输入Runner的描述，你可以稍后在GitLab的用户界面中进行更改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Please enter the gitlab-ci description for this runner
my-runner
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输入与Runner关联的标签，稍后可以在GitLab的用户界面中进行更改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Please enter the gitlab-ci tags for this runner (comma separated):
go
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;选择Runner是否应该选择没有标签的作业，以后可以在GitLab的用户界面中更改它（默认为false）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Whether to run untagged jobs [true/false]:
true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;选择是否将Runner锁定到当前项目，您可以稍后在GitLab的用户界面中进行更改。Runner特定时有用（默认为true）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Whether to lock Runner to current project [true/false]:
true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输入Runner执行者：
如果您选择Docker作为您的执行程序，则会要求您为默认图像用于未在其中定义一个的项目.gitlab-ci.yml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:
docker
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编辑.gitlab-ci.yml文件, 这里使用docker运行环境，省去了构建编译环境的麻烦。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;image: golang:latest

variables:
  REPO_NAME: project

before_script:
  - mkdir -p $GOPATH/src/$(dirname $REPO_NAME)
  - ln -svf $CI_PROJECT_DIR $GOPATH/src/$REPO_NAME
  - cd $GOPATH/src/$REPO_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;image: golang:latest&lt;/code&gt;这里告诉Runner将代码运行在哪个容器内运行。&lt;code&gt;variables: REPO_NAME: project&lt;/code&gt; 配置变量，跟shell里的变量是一个意思。&lt;code&gt;before_script&lt;/code&gt;在执行所有步骤之前执行的一段脚本。这里我们在go/src/目录下根据项目名称创建了一个文件夹，然后从$CI_PROJECT_DIR环境变量获取到代码现在存在的目录，将目录建立一个软链接链接到刚刚创建的go/src/project目录。这样我们就完成了go编译环境的搭建，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;stages:
    - test
    - build
    - deploy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;stages 用于定义执行步骤，每个步骤可以在job中使用。stages的排序定义了Job执行的顺序：
根据上面定义。首先所有被定义为test的job会并行执行，如果所有的test都执行成功了然后就会执行所有定义为build的job.如果任何先前的Job失败，则提交被标记为failed并且不执行下一步&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test:
    stage: test
    script:
      - cd tests
      - go test -v

compile:
  stage: build
  script:
    - go build -o $CI_PROJECT_DIR/demo
  artifacts:
    paths:
      - demo
 
 deploy_develop:
  stage: deploy
  script:
    - echo &amp;quot;$SSH_PRIVATE_KEY&amp;quot; &amp;gt;&amp;gt; ~/.ssh/id_dsa
    - chmod 600 ~/.ssh/id_dsa
    - echo -e &amp;quot;Host *\n\tStrictHostKeyChecking no\n\n&amp;quot; &amp;gt; ~/.ssh/config
    - rsync $CI_PROJECT_DIR/demo root@xxxx:/root/program
    - ssh root@xxxx &amp;quot;/usr/bin/supervisorctl restart demo&amp;quot;
  only:
    - develop
 
deploy_production:
  stage: deploy
  script:
    - echo &amp;quot;$SSH_PRIVATE_KEY&amp;quot; &amp;gt;&amp;gt; ~/.ssh/id_dsa
    - chmod 600 ~/.ssh/id_dsa
    - echo -e &amp;quot;Host *\n\tStrictHostKeyChecking no\n\n&amp;quot; &amp;gt; ~/.ssh/config
    - rsync $CI_PROJECT_DIR/demo root@xxxx:/root/program
    - ssh root@xxxx &amp;quot;/usr/bin/supervisorctl restart demo&amp;quot;
  only:
    - master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里定义了4个job分别是test,compile,deploy_production,deploy_develop,首先我们执行测试，测试成功后编译出一个可执行文件，然后根据不同的提交分支发布到不同的服务器上部署&lt;/p&gt;
&lt;p&gt;fatal: repository &#39;http://gitlab-ci-token:xxxxxxxxxxxxxxxxxxxx@192.168.15.95/lintao/work-doc.git/&#39; not found
错误处理
vim /etc/gitlab-runner/config.toml
clone_url = &amp;quot;http://192.168.15.95:8080/&amp;quot;&lt;/p&gt;
&lt;p&gt;FROM golang:latest&lt;/p&gt;
&lt;p&gt;RUN apt-get update -y &amp;amp;&amp;amp; apt-get install openssh-client -y &amp;amp;&amp;amp; apt-get update -y &amp;amp;&amp;amp; apt-get install rsync -y &amp;amp;&amp;amp; mkdir -p ~/.ssh&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Mac安装Gitlab</title>
            <link rel="alternate" type="text/html" href="http://lt7.top/posts/mac%E5%AE%89%E8%A3%85gitlab/" />
            <id>http://lt7.top/posts/mac%E5%AE%89%E8%A3%85gitlab/</id>
            <updated>2021-05-13T10:03:57&#43;08:00</updated>
            <published>2018-02-22T22:53:00&#43;08:00</published>
            <author>
                    <name>lintao</name>
                    <uri>https://lt7.top/</uri>
                    <email>mrqter@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary>
            
                <content type="html">&lt;p&gt;安装环境:
Docker
&lt;a href=&#34;https://hub.docker.com/r/twang2218/gitlab-ce-zh/&#34;&gt;Gitlab中文镜像&lt;/a&gt;
4GB内存&lt;/p&gt;
&lt;p&gt;Docker安装:&lt;/p&gt;
&lt;p&gt;Mac版本下载地址
&lt;a href=&#34;https://store.docker.com/editions/community/docker-ce-desktop-mac&#34;&gt;https://store.docker.com/editions/community/docker-ce-desktop-mac&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载完docker后添加Daocloud加速器
&lt;a href=&#34;http://www.daocloud.io/mirror#accelerator-doc&#34;&gt;http://www.daocloud.io/mirror#accelerator-doc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://7u2kla.com1.z0.glb.clouddn.com/%E5%8A%A0%E9%80%9F%E5%99%A8_DaoCloud_-_%E4%B8%9A%E7%95%8C%E9%A2%86%E5%85%88%E7%9A%84%E5%AE%B9%E5%99%A8%E4%BA%91%E5%B9%B3%E5%8F%B0.png&#34; alt=&#34;加速器_DaoCloud_-_业界领先的容器云平台&#34;&gt;&lt;/p&gt;
&lt;p&gt;下载中文版Gitlab镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker pull twang2218/gitlab-ce-zh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动容器:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -d \
    --hostname gitlab.example.com \
    -p 80:80 \
    -p 443:443 \
    -p 22:22 \
    --name gitlab \
    --restart unless-stopped \
    -v gitlab-config:/etc/gitlab \
    -v gitlab-logs:/var/log/gitlab \
    -v gitlab-data:/var/opt/gitlab \
    --network gitlab-net \
    twang2218/gitlab-ce-zh:10.4.3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;进入容器修改配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec -it gitlab bash
vi /etc/gitlab/gitlab.rb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改时区&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; gitlab_rails[&#39;time_zone&#39;] = &#39;Asia/Shanghai&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置邮箱:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;### Email Settings
 gitlab_rails[&#39;smtp_enable&#39;] = true
 gitlab_rails[&#39;smtp_address&#39;] = &amp;quot;smtp.qq.com&amp;quot;
 gitlab_rails[&#39;smtp_port&#39;] = 465
 gitlab_rails[&#39;smtp_user_name&#39;] = &amp;quot;xxxx@qq.com&amp;quot;
 gitlab_rails[&#39;smtp_password&#39;] = &amp;quot;xxxx&amp;quot;
 gitlab_rails[&#39;smtp_authentication&#39;] = &amp;quot;login&amp;quot;
 gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] = true
 gitlab_rails[&#39;smtp_tls&#39;] = true
 gitlab_rails[&#39;gitlab_email_from&#39;] = &#39;xxxx@qq.com&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改完后更新下配置，&lt;a href=&#34;https://docs.gitlab.com/omnibus/settings/smtp.html&#34;&gt;更多邮箱配置参考&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gitlab-ctl reconfigure
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在浏览器打开http://127.0.0.1 首次安装会要几分钟初始化。可能会出现500的情况，初始化完成后就能使用了。
&lt;img src=&#34;http://7u2kla.com1.z0.glb.clouddn.com/%E6%98%9F%E6%A0%87%E9%A1%B9%E7%9B%AE_%C2%B7_%E4%BB%AA%E8%A1%A8%E7%9B%98_%C2%B7_GitLab_%E5%92%8C_2018-02-22_md.png&#34; alt=&#34;星标项目_·_仪表盘_·_GitLab_和_2018-02-22_md&#34;&gt;&lt;/p&gt;
&lt;p&gt;Gitlab文档
&lt;a href=&#34;https://docs.gitlab.com/omnibus/README.html&#34;&gt;https://docs.gitlab.com/omnibus/README.html&lt;/a&gt;&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">搭建Shadowsocks服务器</title>
            <link rel="alternate" type="text/html" href="http://lt7.top/posts/%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8/" />
            <id>http://lt7.top/posts/%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
            <updated>2021-05-13T10:03:57&#43;08:00</updated>
            <published>2017-11-01T11:56:56&#43;08:00</published>
            <author>
                    <name>lintao</name>
                    <uri>https://lt7.top/</uri>
                    <email>mrqter@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary>
            
                <content type="html">&lt;p&gt;最近VPN总是掉线连不上，所以决定自己搭建一个Shadowsocks服务器,找了各种教程后发现搭建Shadowsocks服务器非常简单
搭建Shadowsocks需要一个在墙外的服务器。
###VPS
免费：
亚马逊有免费1年的vps服务器，只需要绑定信用卡就可以了。
付费：
&lt;a href=&#34;https://www.vultr.com&#34;&gt;https://www.vultr.com&lt;/a&gt;
&lt;a href=&#34;https://bandwagonhost.com/cart.php&#34;&gt;https://bandwagonhost.com/cart.php&lt;/a&gt;
&lt;a href=&#34;https://bandwagonhost.com&#34;&gt;https://bandwagonhost.com&lt;/a&gt;
&lt;a href=&#34;https://www.linode.com&#34;&gt;https://www.linode.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果对网速有要求只能选香港的vps,看youtube 4K无压力，平时只是用用google推荐使用vultr。创建服务器前最好先测试下网速。&lt;/p&gt;
&lt;p&gt;linode
&lt;a href=&#34;https://www.linode.com/speedtest&#34;&gt;https://www.linode.com/speedtest&lt;/a&gt;
vultr 打开网页后搜索How can I test Vultr download speeds?
&lt;a href=&#34;https://www.vultr.com/faq/&#34;&gt;https://www.vultr.com/faq/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;###安装GO
首先在官网找到最新二进制版本的连接
&lt;a href=&#34;https://golang.org/dl/&#34;&gt;https://golang.org/dl/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;####下载二进制包
&lt;code&gt;wget https://storage.googleapis.com/golang/go1.8.1.linux-amd64.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;####解压到Local目录下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo tar -xzf go1.8.1.linux-amd64.tar.gz -C /usr/local&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;####设置环境变量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim /etc/profile&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export PATH=$PATH:/usr/local/go/bin
export GOPATH=$HOME/work
export PATH=$GOPATH/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;source /etc/profile&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;###安装supervisor
&lt;code&gt;apt-get -y install supervisor&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim /etc/supervisor/conf.d/shadowsocks.conf&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[program:shadowsocks]
command=/root/work/bin/shadowsocks-server -c config.json
directory=/root
autostart=true
autorestart=true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###安装Go版本shadowsocks
&lt;code&gt;go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;####创建配置文件
&lt;code&gt;vim config.json&lt;/code&gt;
####参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server          vps公网ip
server_port     服务器端口， 需要在安全组里打开这个端口，不然客户端无法访问
local_port      本地socks5代理端口
method          加密方式,下面是所有支持的加密方式:
                 aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, chacha20, salsa20, rc4,
password        用于加密传输的密码r
timeout         超时设置，以秒为单位
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;{
  &amp;quot;server&amp;quot;:&amp;quot;xxx.xxx.xxx.xx&amp;quot;,
  &amp;quot;server_port&amp;quot;:2333,
  &amp;quot;local_port&amp;quot;:1080,
  &amp;quot;password&amp;quot;:&amp;quot;123456&amp;quot;,
  &amp;quot;timeout&amp;quot;:60,
  &amp;quot;method&amp;quot;:&amp;quot;aes-256-cfb&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Mac os使用
首先下载客户端,NG是最新版的功能比较多。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://sourceforge.net/projects/shadowsocksgui/?source=typ_redirect
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;https://github.com/shadowsocks/ShadowsocksX-NG/releases/download/v1.6.1/ShadowsocksX-NG.1.6.1.zip
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;iOS推荐使用Wingy，非常方便的小工具
&lt;img src=&#34;http://7u2kla.com1.z0.glb.clouddn.com/15101075736153.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;linux上使用
先下载客户端程序。然后编辑config文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;{
    &amp;quot;server&amp;quot;:&amp;quot;xx.xx.xx.xx&amp;quot;, 服务器地址
    &amp;quot;server_port&amp;quot;:8080, 服务器端口
    &amp;quot;local_port&amp;quot;:1080, 本地监听的端口
    &amp;quot;password&amp;quot;:&amp;quot;123456&amp;quot;,
    &amp;quot;method&amp;quot;: &amp;quot;aes-128-cfb-auth&amp;quot;,
    &amp;quot;timeout&amp;quot;:600
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在后台启动这个服务
&lt;code&gt;nohup ./shadowsocks-local config.json &amp;amp;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在linux上使用需要浏览器设置好代理方式。以firefox为例;
先安装AutoProxy-ng插件
&lt;img src=&#34;http://7u2kla.com1.z0.glb.clouddn.com/15101081468737.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Mysql配置主从同步</title>
            <link rel="alternate" type="text/html" href="http://lt7.top/posts/mysql%E9%85%8D%E7%BD%AE%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/" />
            <id>http://lt7.top/posts/mysql%E9%85%8D%E7%BD%AE%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</id>
            <updated>2021-05-13T10:03:57&#43;08:00</updated>
            <published>2017-11-01T10:07:29&#43;08:00</published>
            <author>
                    <name>lintao</name>
                    <uri>https://lt7.top/</uri>
                    <email>mrqter@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">……</summary>
            
                <content type="html">&lt;p&gt;参考
&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/replication.html&#34;&gt;Mysql官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##主机配置:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改My.conf&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;server-id              = 1&lt;/code&gt;
主机Id
&lt;code&gt;log_bin           		= mast-binlog&lt;/code&gt;
binlog存放位置
&lt;code&gt;log-bin-index           = master-binlog.index&lt;/code&gt;
存放binlog索引
&lt;code&gt;expire_logs_days       = 10&lt;/code&gt;
binlog过期时间
&lt;code&gt;max_binlog_size        = 200M&lt;/code&gt;
binlog文件大小
&lt;code&gt;binlog_do_db           = database&lt;/code&gt;
binlog只对那些库启用&lt;/p&gt;
&lt;p&gt;确保skip-networking主服务器上未启用该选项。如果网络被禁用，则从机不能与主机通信，并且复制失败。
确保bind-address主机上没有启用改选项或者修改成0.0.0.0&lt;/p&gt;
&lt;p&gt;log_bin和log-bin-index可以自定义存储目录。修改默认存储路径时需要修改mysql的访问权限。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim /etc/apparmor.d/usr.sbin.mysqld
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置好My.conf和apparmor后需要重启配置才能生效&lt;/p&gt;
&lt;p&gt;在主机上创建一个用户给从机连接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE USER &#39;slave_mysql&#39;@&#39;%&#39; IDENTIFIED BY &#39;mmp123&#39;;
GRANT REPLICATION SLAVE ON *.* TO &#39;slave_mysql&#39;@&#39;%&#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建完用户有刷新权限
&lt;code&gt;flush privileges;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;锁住数据库用mysqldump将这个数据库备份发给从机，配置好从机再解锁&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FLUSH TABLES WITH READ LOCK;
UNLOCK TABLES;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看主机当前在用哪个binlog文件写入和写入位置&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SHOW MASTER STATUS;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;File                   postion   Binglog-Do-DB
master-bin.00001    	004       database
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从机配置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改My.conf&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
```server-id = 2```
从机ID不能和主机一样
```replicate-do-db=database```
需要备份那些库
```relay_log    = server-relay-bin```
中继日志存放位置。从机从主机获取数据后先会放入中继日志，然后从中继中读取sql语句。

配置好my.conf后重启从机，然后在从机配置主机信息

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/change-master-to.html&#34;&gt;CHANGE MASTER TO 完整语法介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从机配置
&lt;a href=&#34;https://mysql.az/2015/04/12/change-binary-log-and-relay-log-location-to-home/&#34;&gt;https://mysql.az/2015/04/12/change-binary-log-and-relay-log-location-to-home/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看Binlog
binlog无法查看解决办法
mysqlbinlog: [ERROR] unknown variable &#39;default-character-set=utf8&#39;
mysqlbinlog --no-defaults --set-charset=utf8 master-bin.080541
查看Row模式下的binlog
mysqlbinlog  --no-defaults --set-charset=utf8 -v --base64-output=DECODE-ROWS master-bin.080541&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/mysqlbinlog-row-events.html&#34;&gt;https://dev.mysql.com/doc/refman/5.7/en/mysqlbinlog-row-events.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;创建过滤规则
CHANGE REPLICATION FILTER filter[, filter][, ...]&lt;/p&gt;
&lt;p&gt;filter:
REPLICATE_DO_DB = (db_list)
| REPLICATE_IGNORE_DB = (db_list)
| REPLICATE_DO_TABLE = (tbl_list)
| REPLICATE_IGNORE_TABLE = (tbl_list)
| REPLICATE_WILD_DO_TABLE = (wild_tbl_list)
| REPLICATE_WILD_IGNORE_TABLE = (wild_tbl_list)
| REPLICATE_REWRITE_DB = (db_pair_list)&lt;/p&gt;
&lt;p&gt;CHANGE REPLICATION FILTER
REPLICATE_IGNORE_TABLE = ()&lt;/p&gt;
&lt;p&gt;db_list:
db_name[, db_name][, ...]&lt;/p&gt;
&lt;p&gt;tbl_list:
db_name.table_name[, db_table_name][, ...]
wild_tbl_list:
&#39;db_pattern.table_pattern&#39;[, &#39;db_pattern.table_pattern&#39;][, ...]&lt;/p&gt;
&lt;p&gt;db_pair_list:
(db_pair)[, (db_pair)][, ...]&lt;/p&gt;
&lt;p&gt;db_pair:
from_db, to_db&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CHANGE REPLICATION FILTER
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;REPLICATE_WILD_IGNORE_TABLE = (&#39;db1.new%&#39;, &#39;db2.new%&#39;);&lt;/p&gt;
&lt;p&gt;日志清理
PURGE MASTER LOGS BEFORE DATE_SUB(CURRENT_DATE, INTERVAL 2 DAY)
&lt;a href=&#34;http://www.ttlsa.com/mysql/mysql-5-7-enhanced-multi-thread-salve/&#34;&gt;http://www.ttlsa.com/mysql/mysql-5-7-enhanced-multi-thread-salve/&lt;/a&gt;
从机开启多线程
STOP SLAVE;
SET GLOBAL master_info_repository = &#39;TABLE&#39;
SET GLOBAL relay_log_info_repository = &#39;TABLE&#39;
SET GLOBAL relay_log_recovery =
SET GLOBAL slave_parallel_type=LOGICAL_CLOCK;
&lt;br&gt;
START slave&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.percona.com/blog/2013/02/08/how-to-createrestore-a-slave-using-gtid-replication-in-mysql-5-6/&#34;&gt;https://www.percona.com/blog/2013/02/08/how-to-createrestore-a-slave-using-gtid-replication-in-mysql-5-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同步出错解决方案
The slave is connecting using CHANGE MASTER TO MASTER_AUTO_POSITION = 1, but the master has purged binary logs containing GTIDs that the slave requires.&lt;/p&gt;
&lt;p&gt;这个是由于在主库上执行过purge binary logs，然后当从库change master的时候，却要执行那些事务。
你可以在主库上先查找哪些gtid被purge了。
show global variables like &#39;gtid_purged&#39;;
然后拿着这个value，去从库上依次
stop slave;
set global gtid_purged = &#39;xxx&#39;; # xxx是你主库上查到的value。
start slave;
这样能跳过执行被主库已经purge的事务了。
如果出现
@@GLOBAL.GTID_PURGED can only be set when @@GLOBAL.GTID_EXECUTED is empty.
reset master后在执行&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
</feed>
